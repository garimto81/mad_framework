/**
 * Markdown Exporter
 *
 * Issue #25: ì„¸ì…˜ì„ Markdown í˜•ì‹ìœ¼ë¡œ ë‚´ë³´ë‚´ê¸°
 * P2: ë¶€ë¶„ ë‚´ë³´ë‚´ê¸° ì§€ì›
 */

import * as fs from 'fs';
import * as path from 'path';
import type { SessionRecord, ExportOptions, PartialExportOptions, MessageRecord } from '../types';

/**
 * ì„¸ì…˜ì„ Markdown í˜•ì‹ìœ¼ë¡œ ë‚´ë³´ë‚´ê¸°
 */
export function exportToMarkdown(
  session: SessionRecord,
  options: ExportOptions = {}
): string {
  const { includeMetadata = true } = options;

  const lines: string[] = [];

  // í—¤ë”
  lines.push('# MAD í† ë¡  ì„¸ì…˜ ê¸°ë¡');
  lines.push('');

  // ì„¸ì…˜ ì •ë³´
  lines.push(`**Session ID**: ${session.id}`);
  lines.push(`**Debate ID**: ${session.debateId}`);
  lines.push(`**Preset**: ${session.config.preset}`);
  lines.push(`**ì‹œì‘**: ${formatDateTime(session.startedAt)}`);
  if (session.endedAt) {
    lines.push(`**ì¢…ë£Œ**: ${formatDateTime(session.endedAt)}`);
  }
  lines.push(`**ìƒíƒœ**: ${translateStatus(session.status)}`);
  lines.push('');

  // í† ë¡  ì£¼ì œ
  lines.push('## í† ë¡  ì£¼ì œ');
  lines.push('');
  lines.push(session.config.topic);
  lines.push('');

  if (session.config.context) {
    lines.push('### ì»¨í…ìŠ¤íŠ¸');
    lines.push('');
    lines.push(session.config.context);
    lines.push('');
  }

  // ì°¸ì—¬ì
  lines.push('## ì°¸ì—¬ì');
  lines.push('');
  lines.push(`- **í† ë¡ ì**: ${session.config.participants.join(', ')}`);
  lines.push(`- **ì‹¬íŒ**: ${session.config.judgeProvider}`);
  lines.push('');

  // ëŒ€í™” ê¸°ë¡
  lines.push('## ëŒ€í™” ê¸°ë¡');
  lines.push('');

  // ë©”ì‹œì§€ë¥¼ iterationë³„ë¡œ ê·¸ë£¹í™”
  const messagesByIteration = groupMessagesByIteration(session.messages);

  for (const [iteration, messages] of Object.entries(messagesByIteration)) {
    lines.push(`### Iteration ${iteration}`);
    lines.push('');

    for (const msg of messages) {
      const roleLabel = msg.role === 'user' ? 'ğŸ“ User' : 'ğŸ¤– Assistant';
      const time = formatTime(msg.timestamp);
      lines.push(`#### ${getProviderEmoji(msg.provider)} ${msg.provider} (${roleLabel}) - ${time}`);
      lines.push('');
      lines.push(msg.content);
      lines.push('');
    }
  }

  // ìš”ì†Œ ê²°ê³¼ (ìˆëŠ” ê²½ìš°)
  if (session.elements.length > 0) {
    lines.push('## í‰ê°€ ìš”ì†Œ');
    lines.push('');
    lines.push('| ìš”ì†Œ | ìƒíƒœ | ì ìˆ˜ | ì™„ë£Œ ì‚¬ìœ  |');
    lines.push('|------|------|------|----------|');

    for (const element of session.elements) {
      const statusEmoji = element.status === 'completed' ? 'âœ…' :
                         element.status === 'cycle_detected' ? 'ğŸ”„' : 'â³';
      const reason = element.completionReason === 'threshold' ? 'ì„ê³„ê°’ ë„ë‹¬' :
                    element.completionReason === 'cycle' ? 'ìˆœí™˜ ê°ì§€' : '-';
      lines.push(`| ${element.name} | ${statusEmoji} ${element.status} | ${element.currentScore} | ${reason} |`);
    }
    lines.push('');
  }

  // ë©”íƒ€ë°ì´í„° (ì˜µì…˜)
  if (includeMetadata) {
    lines.push('## ë©”íƒ€ë°ì´í„°');
    lines.push('');
    lines.push(`- **ì´ í† í°**: ${session.metadata.totalTokens.toLocaleString()}`);
    lines.push(`- **ì´ ë°˜ë³µ**: ${session.metadata.totalIterations}íšŒ`);
    lines.push(`- **ì‚¬ìš© Provider**: ${session.metadata.providersUsed.join(', ')}`);
    if (session.metadata.completionReason) {
      lines.push(`- **ì™„ë£Œ ì‚¬ìœ **: ${translateCompletionReason(session.metadata.completionReason)}`);
    }
    lines.push('');
  }

  // í‘¸í„°
  lines.push('---');
  lines.push(`*Generated by MAD Framework at ${formatDateTime(new Date().toISOString())}*`);

  return lines.join('\n');
}

/**
 * ì„¸ì…˜ì„ Markdown íŒŒì¼ë¡œ ì €ì¥
 */
export async function exportToMarkdownFile(
  session: SessionRecord,
  outputPath: string,
  options: ExportOptions = {}
): Promise<void> {
  const markdown = exportToMarkdown(session, options);

  // ë””ë ‰í† ë¦¬ê°€ ì—†ìœ¼ë©´ ìƒì„±
  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(outputPath, markdown, 'utf-8');
  console.log(`[MarkdownExporter] Exported session to: ${outputPath}`);
}

/**
 * ê¸°ë³¸ ë‚´ë³´ë‚´ê¸° íŒŒì¼ëª… ìƒì„±
 */
export function getDefaultMarkdownFilename(session: SessionRecord): string {
  const date = new Date(session.startedAt);
  const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
  const timeStr = date.toISOString().slice(11, 19).replace(/:/g, '');
  return `mad-session-${dateStr}-${timeStr}-${session.id.slice(-6)}.md`;
}

// Helper functions

function formatDateTime(isoString: string): string {
  const date = new Date(isoString);
  return date.toLocaleString('ko-KR', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  });
}

function formatTime(isoString: string): string {
  const date = new Date(isoString);
  return date.toLocaleTimeString('ko-KR', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  });
}

function translateStatus(status: string): string {
  const statusMap: Record<string, string> = {
    active: 'ì§„í–‰ ì¤‘',
    completed: 'ì™„ë£Œ',
    cancelled: 'ì·¨ì†Œë¨',
    error: 'ì˜¤ë¥˜',
  };
  return statusMap[status] || status;
}

function translateCompletionReason(reason: string): string {
  const reasonMap: Record<string, string> = {
    consensus: 'í•©ì˜ ë„ë‹¬',
    cycle: 'ìˆœí™˜ ê°ì§€',
    maxIterations: 'ìµœëŒ€ ë°˜ë³µ ë„ë‹¬',
    cancelled: 'ì‚¬ìš©ì ì·¨ì†Œ',
    error: 'ì˜¤ë¥˜ ë°œìƒ',
  };
  return reasonMap[reason] || reason;
}

function getProviderEmoji(provider: string): string {
  const emojiMap: Record<string, string> = {
    chatgpt: 'ğŸ’š',
    claude: 'ğŸŸ ',
    gemini: 'ğŸ”µ',
  };
  return emojiMap[provider] || 'âšª';
}

function groupMessagesByIteration(
  messages: SessionRecord['messages']
): Record<number, SessionRecord['messages']> {
  const grouped: Record<number, SessionRecord['messages']> = {};

  for (const msg of messages) {
    if (!grouped[msg.iteration]) {
      grouped[msg.iteration] = [];
    }
    grouped[msg.iteration].push(msg);
  }

  return grouped;
}

/**
 * ë©”ì‹œì§€ í•„í„°ë§ í—¬í¼ (P2)
 */
function filterMessages(
  messages: MessageRecord[],
  options: PartialExportOptions
): MessageRecord[] {
  const { iterations, providers, roles, fromTime, toTime } = options;
  let filtered = messages;

  if (iterations && iterations.length > 0) {
    filtered = filtered.filter((msg) => iterations.includes(msg.iteration));
  }

  if (providers && providers.length > 0) {
    filtered = filtered.filter((msg) => providers.includes(msg.provider));
  }

  if (roles && roles.length > 0) {
    filtered = filtered.filter((msg) => roles.includes(msg.role));
  }

  if (fromTime) {
    const fromDate = new Date(fromTime).getTime();
    filtered = filtered.filter((msg) => new Date(msg.timestamp).getTime() >= fromDate);
  }

  if (toTime) {
    const toDate = new Date(toTime).getTime();
    filtered = filtered.filter((msg) => new Date(msg.timestamp).getTime() <= toDate);
  }

  return filtered;
}

/**
 * ë¶€ë¶„ ë‚´ë³´ë‚´ê¸° (P2)
 */
export function exportToMarkdownPartial(
  session: SessionRecord,
  options: PartialExportOptions = {}
): string {
  const { includeMetadata = true } = options;

  // ë©”ì‹œì§€ í•„í„°ë§
  const filteredMessages = filterMessages(session.messages, options);

  const lines: string[] = [];

  // í—¤ë”
  lines.push('# MAD í† ë¡  ì„¸ì…˜ ê¸°ë¡ (ë¶€ë¶„)');
  lines.push('');

  // í•„í„° ì •ë³´
  lines.push('> ë¶€ë¶„ ë‚´ë³´ë‚´ê¸°');
  if (options.iterations) {
    lines.push(`> - Iterations: ${options.iterations.join(', ')}`);
  }
  if (options.providers) {
    lines.push(`> - Providers: ${options.providers.join(', ')}`);
  }
  if (options.roles) {
    lines.push(`> - Roles: ${options.roles.join(', ')}`);
  }
  lines.push('');

  // ì„¸ì…˜ ì •ë³´
  lines.push(`**Session ID**: ${session.id}`);
  lines.push(`**Debate ID**: ${session.debateId}`);
  lines.push(`**Preset**: ${session.config.preset}`);
  lines.push(`**ì‹œì‘**: ${formatDateTime(session.startedAt)}`);
  if (session.endedAt) {
    lines.push(`**ì¢…ë£Œ**: ${formatDateTime(session.endedAt)}`);
  }
  lines.push(`**ìƒíƒœ**: ${translateStatus(session.status)}`);
  lines.push('');

  // í† ë¡  ì£¼ì œ
  lines.push('## í† ë¡  ì£¼ì œ');
  lines.push('');
  lines.push(session.config.topic);
  lines.push('');

  // ëŒ€í™” ê¸°ë¡
  lines.push('## ëŒ€í™” ê¸°ë¡');
  lines.push('');

  const messagesByIteration = groupMessagesByIteration(filteredMessages);

  for (const [iteration, messages] of Object.entries(messagesByIteration)) {
    lines.push(`### Iteration ${iteration}`);
    lines.push('');

    for (const msg of messages) {
      const roleLabel = msg.role === 'user' ? 'ğŸ“ User' : 'ğŸ¤– Assistant';
      const time = formatTime(msg.timestamp);
      lines.push(`#### ${getProviderEmoji(msg.provider)} ${msg.provider} (${roleLabel}) - ${time}`);
      lines.push('');
      lines.push(msg.content);
      lines.push('');
    }
  }

  // ë©”íƒ€ë°ì´í„° (í•„í„°ë§ëœ ë²„ì „)
  if (includeMetadata) {
    const filteredMetadata = {
      totalTokens: filteredMessages.reduce((sum, msg) => sum + (msg.tokenCount || 0), 0),
      totalIterations: Math.max(0, ...filteredMessages.map((msg) => msg.iteration)),
      providersUsed: [...new Set(filteredMessages.map((msg) => msg.provider))],
    };

    lines.push('## ë©”íƒ€ë°ì´í„° (í•„í„°ë§ë¨)');
    lines.push('');
    lines.push(`- **í•„í„°ë§ëœ ë©”ì‹œì§€ ìˆ˜**: ${filteredMessages.length}ê°œ`);
    lines.push(`- **ì´ í† í°**: ${filteredMetadata.totalTokens.toLocaleString()}`);
    lines.push(`- **ì´ ë°˜ë³µ**: ${filteredMetadata.totalIterations}íšŒ`);
    lines.push(`- **ì‚¬ìš© Provider**: ${filteredMetadata.providersUsed.join(', ')}`);
    lines.push('');
  }

  // í‘¸í„°
  lines.push('---');
  lines.push(`*Generated by MAD Framework (Partial Export) at ${formatDateTime(new Date().toISOString())}*`);

  return lines.join('\n');
}

/**
 * ë¶€ë¶„ ë‚´ë³´ë‚´ê¸°ë¥¼ íŒŒì¼ë¡œ ì €ì¥ (P2)
 */
export async function exportToMarkdownFilePartial(
  session: SessionRecord,
  outputPath: string,
  options: PartialExportOptions = {}
): Promise<void> {
  const markdown = exportToMarkdownPartial(session, options);

  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(outputPath, markdown, 'utf-8');
  console.log(`[MarkdownExporter] Exported partial session to: ${outputPath}`);
}
